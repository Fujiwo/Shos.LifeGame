# Shos.LifeGame 記事計画書(再設計版 / 物語軸対応)

## 0. この再設計の狙い
- これまでの「要素列挙中心」の構成から、**読者の疑問が自然に解消される物語構成**へ移行する。
- 主軸は「**なぜ遅いのか → どこを速くしたのか → どこまで速くなったのか**」。
- 実装根拠(`ShosLifeGame.h` / `ShosLifeGameBoardPainter.h` / `Shos.LifeGame.Test.cpp`)は維持し、説明順だけを読者理解優先へ最適化する。

---

## 1. 読者像(定義完了)

### 1-1. 主読者(ペルソナA)
- C++初級後半〜中級。
- LifeGame のルールは知っているが、最適化の整理軸が曖昧。
- 「マクロ切替が多くて、どこを見ると速さの理由が分かるのか」を知りたい。

### 1-2. 副読者(ペルソナB)
- Win32描画や低レベルデータ構造に関心のある実装者。
- `GetBits()` → `CreateBitmapIndirect` → `BitBlt` の実用的な描画経路を学びたい。

### 1-3. 除外する読者
- C++文法未習得層(ポインタ/前処理/スレッドが未経験)。
- 数学的厳密性だけを求める理論中心読者(本記事は実装読解が中心)。

---

## 2. 物語軸(ストーリーライン)

### 2-1. 1本目の軸(性能)
1. LifeGameは単純でも全セル反復で重くなる。  
2. `Shos.LifeGame` は5要素(`USEBOOL` / `FAST` / `MT` / `AREA` / `BoardPainter`)でボトルネックを分解している。  
3. 実測例(`23.363s / 9.109s / 3.270s`)で改善の方向性を確認する。

### 2-2. 2本目の軸(データと描画)
1. パターン入力(`.lif` / `.rle`)を内部表現へ落とす。  
2. `Board`/`BitCellSet` で世代更新を進める。  
3. `GetBits()` のビット列を描画へ直結して表示する。

### 2-3. 各章で読者が持つべき問い
- 第1章: なぜ遅くなるのか?
- 第2章: この実装はどこで何をしているのか?
- 第3章: 入力データはどう解釈されるのか?
- 第4章: 更新はどの流れで行われるのか?
- 第5章: 5要素は何に効くのか?
- 第6章: 数字としてどう読むべきか?
- 第7章: 次に自分は何を試すべきか?

---

## 3. 記事タイトル案(3案)
1) **C++/Win32で学ぶ高速LifeGame実装:Shos.LifeGame徹底解説**  
2) **Shos.LifeGameの設計と最適化:5要素で追う高速化の実装読解**  
3) **LifeGameはなぜ速くなるのか:Shos.LifeGameで学ぶ実装と検証**

---

## 4. 到達目標(読了後にできること)
- 5要素(`USEBOOL` / `FAST` / `MT` / `AREA` / `BoardPainter`)の役割を、実装箇所付きで説明できる。
- `Game::Next` / `NextPart` と描画経路(`GetBits()` → `BitBlt`)の関係を説明できる。
- `.lif` と `.rle` の違いを、`CellData` の具体例とともに説明できる。
- ベンチ値を鵜呑みにせず、比較条件を揃えて再解釈できる。

---

## 5. 記事構成(物語順)

## はじめに
### H3: この記事で答える問い
### H3: 読者前提と読み方

## 1. Lifegameとは何か
### 1.1 ルールの最小整理
### 1.2 なぜ実装で差が出るのか

## 2. Shos.LifeGameの全体像
### 2.1 主要クラスと責務
### 2.2 実行ループ(`MainWindow::Next`)
### 2.3 パターン読込の入口

## 3. パターンファイル形式とCellDataの読み解き
### 3.1 `.lif` の要点
### 3.2 `.rle` の要点
### 3.3 `CellData` をどう使い分けるか

## 4. データ構造と更新処理の基礎
### 4.1 `Board` と `BitCellSet`
### 4.2 `Game::Next` と `NextPart`
### 4.3 描画パイプライン(`BoardPainter`)

## 5. 高速化テクニック5要素の実装読解
### 5.1 USEBOOL(表現切替)
### 5.2 FAST(ループ最適化)
### 5.3 MT(並列化)
### 5.4 AREA(領域限定)
### 5.5 BoardPainter(描画転送最適化)

## 6. 比較検証の進め方
### 6.1 条件の揃え方
### 6.2 指標の取り方
### 6.3 既存実測値の読み解き

## 7. まとめ
### 7.1 5要素の使い分け
### 7.2 次の改善候補

## 付録
### A. 図版・画像チェックリスト
### B. 参考実装一覧

### 5-1. 章導入フックと章末ブリッジ(読みもの強化)
| 章 | 章導入フック(冒頭1文) | 章末ブリッジ(次章への1文) |
|---|---|---|
| はじめに | 「同じルールのLifeGameでも、実装次第で体感速度は大きく変わる。」 | 「まずは、なぜ差が生まれるかを最小ルールから確認する。」 |
| 1章 | 「遅さの原因は、ルールではなく“適用のしかた"にある。」 | 「次章で、Shos.LifeGameがどこで何を処理しているか地図を作る。」 |
| 2章 | 「全体像が分かると、最適化ポイントは急に見つけやすくなる。」 | 「次章では、入力パターンが内部データへ変換される流れを見る。」 |
| 3章 | 「同じ形でも、`.lif` と `.rle` は“書き方の思想"が違う。」 | 「次章で、取り込まれたデータが世代更新と描画へどう流れるかを追う。」 |
| 4章 | 「更新処理と描画処理を一本の線で捉えると、ボトルネックが見える。」 | 「次章では、この線上のどこを5要素で速くするのかを分解する。」 |
| 5章 | 「速くする手段は5つあるが、効く場所と副作用はそれぞれ違う。」 | 「次章では、実測値を“結論先出し"で確認し、読み解き方を整理する。」 |
| 6章 | 「先に結果を見ると、どの最適化を深掘りすべきか判断しやすい。」 | 「最後に、用途別の使い分けとして知識を持ち帰る。」 |
| 7章 | 「最適化は正解探しではなく、条件に合わせた選択である。」 | 「付録で図と実装参照先を確認し、再現・再測定へ進む。」 |

---

## 6. 章ごとのメッセージ(読者の感情遷移つき)
- はじめに: 「この記事で何が分かるか」を先に提示し、不安を下げる。
- 第1章: 「遅い理由は難解ではない」と納得させる。
- 第2章: まず地図(全体像)を渡し、迷子を防ぐ。
- 第3章: 入力形式の差を図で可視化し、記号の壁を越える。
- 第4章: 更新→描画の流れを一本化して理解させる。
- 第5章: 5要素を「効く場所」で整理し、暗記でなく構造理解へ導く。
- 第6章: 数値の扱い方を示し、誤解(万能最適化)を防ぐ。
- 第7章: 次の一歩を示して学習を継続可能にする。

### 6-1. 第6章の構成ルール(結論先出し)
- 第6章冒頭に「Result / FAST / MT の要約表」を最初に置く。
- その後に「測定条件」「環境依存注記」「解釈ポイント」を並べる。
- 読者が先に成果を掴み、後から正しい読み方へ進める順序にする。

---

## 7. 図版連携計画(本文との結び付け)

| 図 | 置き場 | 本文で答える問い | キャプション要件 |
|---|---|---|---|
| 図1 実行画面 | はじめに | 何が動くアプリなのか? | 画面で分かる情報(世代/FPS)を明記 |
| 図2 ルール図 | 1章 | 更新判定は何で決まるか? | 誕生/生存条件を1文で明記 |
| 図3 クラス関係 | 2章 | どのクラスが何を担当するか? | 責務分担を1文で明記 |
| 図4 LIF/RLE対応 | 3章 | 形式差は何か? | 同一形状を別表現で示す |
| 図5 CellData分類 | 3章 | どのパターンを何に使うか? | カテゴリ用途を1文で明記 |
| 図6 更新パイプライン | 4章 | 1ステップの処理順は? | `Next`→`Paint` の流れを明示 |
| 図7 Bits→Bitmap | 4章 | ビット列はどう描画されるか? | `GetBits` と `BitBlt` を明記 |
| 図8 最適化マップ | 5章 | 5要素はどこに効くか? | レイヤー別効果を明記 |
| 図9 処理方式比較 | 5章 | 面積限定/並列の差は? | 比較観点(面積・並列)を明記 |
| 図10 ベンチ結果 | 6章 | どこまで速くなったか? | 条件(サイズ/回数/環境依存)を明記 |

---

## 8. 高速化5要素の解説テンプレート(統一フォーマット)
### 8-0. 章冒頭の比較表(先出し)
- 第5章の冒頭に、5要素の比較表(効く条件 / 効きにくい条件 / 主な副作用)を置く。
- 本文は比較表の各行を「なぜそうなるか」で掘り下げる。

各要素を次の順で記述する。
1. 何を切り替えるか  
2. どのボトルネックに効くか  
3. 期待効果と副作用  
4. どんな条件で効きやすいか  
5. どのコードを見れば確認できるか

### 8-1. USEBOOL
- 切替: `Board` の保持形式(`bool**` vs `BitCellSet`)。
- 本実装での基本方針: 速度重視なら `USEBOOL` は FALSE(未定義)を基本とする。
- 主効果: 実装単純化の可能性。
- 副作用: メモリ増、`GetBits()` 変換コスト。

### 8-2. FAST
- 切替: 汎用反復から直接ループへ。
- 主効果: 関数呼び出しオーバーヘッド削減。
- 副作用: 可読性・再利用性の低下。

### 8-3. MT
- 切替: Y分割で `NextPart` 並列化。
- 主効果: 大盤面でスループット向上。
- 副作用: 同期コスト、環境依存。

### 8-4. AREA
- 切替: 活動領域のみ更新。
- 主効果: 疎パターンで計算量圧縮。
- 副作用: 領域管理の複雑化。

### 8-5. BoardPainter
- 切替: `GetBits()` を `bmBits` に直結し `BitBlt` 転送。
- 主効果: 中間変換を減らして描画負荷を抑制。
- 副作用: 1bpp/GDI依存で可搬性低下。

### 8-6. 体験ミニ物語(第3章に挿入)
- 例題シナリオ: `Spaceship_Glider.lif` → `Gun_GosperGliderGun.lif` → `OTCA_metapixel.rle` の順に実行。
- 目的: 「軽い移動パターン」から「継続発生」「大規模化」へ負荷と挙動がどう変わるかを読者が追体験できるようにする。
- 記述ルール: 1パターンあたり3行(見た目 / 計算負荷の直感 / どの最適化が効きやすいか)で簡潔に書く。

---

## 9. 検証・数値掲載ルール
- 掲載値は `Shos.LifeGame.Test.cpp` コメント値(Result `23.363s`, FAST `9.109s`, MT `3.270s`)を成果例として扱う。
- 表と図10の両方に同値を反映する。
- 断定を避け、必ず環境依存注記を添える。
- 可能なら再測定時に `Release/盤面サイズ/反復回数` を併記する。

---

## 10. 参考実装一覧(本文リンク元)
- `Shos.LifeGame/ShosLifeGame.h`
  - `Game::Next`, `Game::NextPart`, `Board`, `BitCellSet`, `PatternSet`
  - マクロ: `USEBOOL`, `FAST`, `MT`, `AREA`
- `Shos.LifeGame/ShosLifeGameBoardPainter.h`
  - `BoardPainter::CreateBitmap`, `BoardPainter::Paint`
- `Shos.LifeGame/Shos.LifeGame.cpp`
  - `MainWindow::Next`, `MainWindow::OnPaint`
- `Shos.LifeGame.Test/Shos.LifeGame.Test.cpp`
  - `Program::Run`, 実測コメント値

---

## 11. 執筆順序(再設計版)
1. はじめに・第1章を先に短く書き、読者の問いを固定する。
2. 第2章で全体地図を示し、以後の章の参照点を作る。
3. 第3章・第4章で入力→更新→描画の流れを接続する。
4. 第5章で5要素をテンプレートで統一説明する。
5. 第6章で数値・図10を配置し、解釈ルールを明示する。
6. 第7章で使い分け指針と次の一歩を提示する。

---

## 12. 完了条件(Definition of Done)
- 読者像が冒頭に明示されている。
- 各章が「問い→答え」の1往復で読める。
- 5要素が同じ説明フォーマットで揃っている。
- 図1〜図10の参照先・キャプション・本文参照が一致している。
- 実測値の注記(環境依存)が表・図・本文で一貫している。

## 13. 文体・用語の統一ルール(可読性仕上げ)
- 本文の語尾トーンは原則として「だ/である調」に統一する(引用文・コードコメントは除く)。
- 用語は次で固定する: 「高速化要素(5要素)」「最適化」「副作用(トレードオフ)」。
- 「テクニック」「手法」などの近義語は見出しでは使わず、本文補足でのみ使用可とする。
- 各章の冒頭1段落は短文中心(2〜4文)で、先に結論を述べる。
- 1節あたりのコード量は最小限にし、必ず「何が分かるか」の1文を直後に置く。
